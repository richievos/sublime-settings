-(defn fib [x]\n  (cond (= x 1) 1\n        (= x 2) 1\n        :else (+ (fib (- x 1)) (fib (- x 2)))))\n\n(defn fib-seq [n]\n	(if (= n 0)\n		[]\n		(conj (fib-seq (- n 1)) (fib n)))\n	)\n\n(fn fib [x]\n  (cond (= x 1) 1\n        (= x 2) 1\n        :else (+ (fib (- x 1)) (fib (- x 2)))))\n\n(defn fib-seq [n]\n	(if (= n 0)\n		[]\n		(conj (fib-seq (- n 1)) (fib n)))\n	)\n\n(let [fiba\n	(fn fib [x]\n	  (cond (= x 1) 1\n	        (= x 2) 1\n	        :else (+ (fib (- x 1)) (fib (- x 2)))))\n	     ]\n	)
-((fn fib-seq [n]\n	(let [fiby\n			(fn fib [x]\n		  (cond (= x 1) 1\n		        (= x 2) 1\n		        :else (+ (fib (- x 1)) (fib (- x 2)))))])\n		(if (= n 0)\n			[]\n			(conj (fib-seq (- n 1)) (fiby n)))\n	)\n3\n)
-((fn fib-seq [n]\n	(let [fiby\n			(fn fib [x]\n		  (cond (= x 1) 1\n		        (= x 2) 1\n		        :else (+ (fib (- x 1)) (fib (- x 2)))))]\n		(if (= n 0)\n			[]\n			(conj (fib-seq (- n 1)) (fiby n))))\n	)\n 6\n )
-(length [1])
-(size [1])
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  ; (= 2 (count l)) (= (first l) (last l))\n		  (:else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l))))\n		  		false\n		  	)\n	)\n) [])
-) [1])
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  ; (= 2 (count l)) (= (first l) (last l))\n		  (:else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)\n		  )\n	)\n) [1 1])
-(def l [1])
-(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  (:else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)\n		  )\n	)\n) [1 2])
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  ; (= 2 (count l)) (= (first l) (last l))\n		  :else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)\n	)\n)\n [1])
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  ; (= 2 (count l)) (= (first l) (last l))\n		  :else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)\n	)\n) [1 1])
-((fn palindrome? [l]\n	(cond (= 0 (count l)) true\n		  (= 1 (count l)) true\n		  ; (= 2 (count l)) (= (first l) (last l))\n		  :else\n		  	(if (= (first l) (last l))\n		  		(palindrome? (reverse (rest (reverse (rest l)))))\n		  		false\n		  	)\n	)\n) [1 2])
-ent]\n				(if (sequential? element)\n					(flatten (concat out element) element)\n					(conj out element)\n				)\n			)\n	)\n) [1])
-(def flatter\n\n(fn flatten_ [s]\n	(println (str "s: " s))\n	(reduce (fn [out element]\n					(println (str "element: " element " out: " out))\n					(if (sequential? element)\n						(concat out (flatten_ element))\n						(conj out element)\n					)\n			)\n		[]\n		s\n	)\n)\n\n)
-(flatter [1 [2] 3])
-(use '[clojure.java.io :only (reader)])
-(def file "/Users/richievos/Documents/workspace/ratty/tmp.csv")
-(def line-number 0)
-(first file-seq (line-seq (reader file)))
-(first (line-seq (reader file)))
-(println (take-nth (line-seq (reader file) 2)))
-(println (take-nth (line-seq (reader file)) 2))
-(println (take-nth 2 (line-seq (reader file))))
-(println (take-nth 0 (line-seq (reader file))))
-(use '[clojure.java.io :only (reader)])
-(def file "/Users/richievos/Documents/workspace/ratty/tmp.csv")
-(def line-number 0)
-(let [file-seq (line-seq (reader file))]\n							(println (nth line-number file-seq))\n							)
-(let [file-seq (line-seq (reader file))]\n							(println (nth file-seq line-number))\n							)
-(mapcat (fn [x] [1]) [2 3 4])
-(mapcat (fn [x] [(+ x 1)]) [2 3 4])
-(def flatter\n\n(fn flatten_ [s]\n	(mapcat (fn [element]\n					(if (sequential? element)\n						(concat (flatten_ element))\n						[element]))\n		s))\n\n)\n(flatter [1 [2] 3])\n(flatter [[1] 2 3])\n(flatter [[1] 2 [3] [[[[4]]]]])
-(def flatter\n\n(fn flatten_ [s]\n	(mapcat (fn [element]\n					(if (sequential? element)\n						(flatten_ element)\n						[element]))\n		s))\n\n)\n(flatter [1 [2] 3])\n(flatter [[1] 2 3])\n(flatter [[1] 2 [3] [[[[4]]]]])
-(tree-seq sequential? [[1] 2])
-(tree-seq sequential? [[1] 2] 1)
-(tree-seq sequential? '[[a [c]] b] a)
-(tree-seq sequential? '((a (c)) b) a)
-this context (NO_SOURCE_FILE:34)\nuser=> (tree-seq sequential? (('a ('c)) 'b) 'a)
-(('a ('c)) 'b)
-('('a '('c)) 'b)
-'(('a ('c))
-)
-(1)
-'(('a ('c)) 'b)
-(tree-seq sequential? '(('a ('c)) 'b) 'a)
-(tree-seq sequential? '(('a ('c)) 'b) 'b)
-(tree-seq sequential? '(('a ('c)) 'b) 'd)
-(tree-seq (fn [x]\n	(println x)\n	(sequential? x)) '(('a ('c)) 'b) 'a)
-a\na)\nuser=> (tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x)) '(('a ('c)) 'b) 'a)
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x)) '(('a ('c)) 'b) 'a)
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  '(('a ('c)) 'b) 'a)
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  '(('a ('c)) 'b) '(('a ('c)) 'b))
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  (fn [x] (first x)) '(('a ('c)) 'b))
-(first '(('a ('c)) 'b))
-(first (first '(('a ('c)) 'b)))
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  (fn [x] (first x)) '(('a ('c)) 'b))
-ote a)
-(quote a)
-(sequential? (quote a))
-1)
-(1)
-'(1)
-(def flatter\n\n(fn flatten_ [s]\n	(reduce (fn [out element]\n					(if (sequential? element)\n						(concat out (flatten_ element))\n						(concat out (element)))\n					)\n			)\n		[]\n		s\n	)\n)\n\n)\n(flatter [1 [2] 3])
-(def flatter\n\n(fn flatten_ [s]\n	(reduce (fn [out element]\n					(if (sequential? element)\n						(concat out (flatten_ element))\n						(concat out (element))))\n		[]\n		s))\n\n)\n(flatter [1 [2] 3])\n(flatter [[1] 2 3])\n(flatter [[1] 2 [3] [[[[4]]]]])
-(def flatter\n\n(fn flatten_ [s]\n	(reduce (fn [out element]\n					(if (sequential? element)\n						(concat out (flatten_ element))\n						(concat out (list element))))\n		[]\n		s))\n\n)\n(flatter [1 [2] 3])\n(flatter [[1] 2 3])\n(flatter [[1] 2 [3] [[[[4]]]]])
-(tree-seq seq? identity '((1 2 (3)) (4)))
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  (fn [x] x) '(('a ('c)) 'b))
-(tree-seq (fn [x]\n	(println (str "x: " x))\n	(sequential? x))\n  (fn [x] x) '(("a" ("c")) "b"))
-(tree-seq (fn [x]\n	(println)\n	(println (str "x: " x))\n	(println)\n	(sequential? x))\n  (fn [x] x) '(("a" ("c")) "b"))
-(tree-seq sequential? x\n  (fn [x] x) '(("a" ("c")) "b"))
-(tree-seq sequential?\n  (fn [x] x) '(("a" ("c")) "b"))
-(tree-seq sequential?\n  identity '(("a" ("c")) "b"))
-(filter (complement\n	(tree-seq sequential?\n  identity '(("a" ("c")) "b"))))
-(filter (complement\n	(tree-seq sequential?\n  identity )) '(("a" ("c")) "b"))
-(filter #(complement\n	(tree-seq sequential?\n  identity %)) '(("a" ("c")) "b"))
-(filter #(complement sequential?)\n	(tree-seq sequential?\n  identity '(("a" ("c")) "b")))
-(filter #(complement sequential?)\n	(tree-seq\n		sequential?\n		identity\n		'(("a" ("c")) "b")))
-(tree-seq\n		sequential?\n		identity\n		'(("a" ("c")) "b"))
-(filter (complement sequential?)\n	(tree-seq\n		sequential?\n		identity\n		'(("a" ("c")) "b")))
-(capitalize "a")
-(clojure.string/capitalize "a")
-(.toUpper "a")
-(.toUpperCase "a")
-(re-matches #"[A-Z]" "Hi")
-(re-matches #"(A-Z)" "Hi")
-(re-matches #"H" "Hi")
-(re-matches #"\\w" "Hi")
-(re-matches #".+" "Hi")
-(filter (re-matcher #"H") "Hi")
-(re-matcher #"H" "Hi")
-(re-seq #"[A-Z]" "Hi")
-(str (re-seq #"[A-Z]" "Hi"))
-(join (re-seq #"[A-Z]" "Hi"))
-(clojure.string/join (re-seq #"[A-Z]" "Hi"))
-(#((clojure.string/join (re-seq #"[A-Z]" %))) "Hi")
-#((clojure.string/join (re-seq #"[A-Z]" %)))
-(#(apply (re-seq #"[A-Z]" %)) "Hi")
-#(apply (re-seq #"[A-Z]" "Hi"))
-\n(apply (re-seq #"[A-Z]" "Hi"))
-#(apply (re-seq #"[A-Z]") "Hi")
-(apply (re-seq #"[A-Z]") "Hi")
-(apply str (re-seq #"[A-Z]") "Hi")
-(apply str (re-seq #"[A-Z]" "Hi"))
-(#(apply str (re-seq #"[A-Z]" %)) "Hi")
-(empty? [])
-(help reduce)
-(doc reduce)
-(first (last []))
-(first nil)
-(first (last [[1] [2]]))
-(butlast [[1] [2]])
-#(reduce (fn [dup_lists element]\n					(let [last_element (first (last dup_lists))]\n						(if (= last_element element)\n							(concat (butlast dup_lists) (concat [(last dup_lists)] [element]))\n							(concat dup_lists [element]))))\n	[]\n	%)
-(#(reduce (fn [dup_lists element]\n					(let [last_element (first (last dup_lists))]\n						(if (= last_element element)\n							(concat (butlast dup_lists) (concat [(last dup_lists)] [element]))\n							(concat dup_lists [element]))))\n	[]\n	%) [1 2 3 3])
-(def dup_lists [[1] [2]])
-(first (last dup_lists))
-(def element 2)
-(concat (butlast dup_lists) (concat (last dup_lists) [element]))
-dup_lists
-(butlast dup_lists)
-(concat (last dup_lists) [element])
-#(reduce (fn [dup_lists element]\n					(let [last_element (first (last dup_lists))]\n						(if (= last_element element)\n							(concat (butlast dup_lists) [(concat (last dup_lists) [element])])\n							(concat dup_lists [element]))))\n	[]\n	%)
-(concat (butlast dup_lists) [(concat (last dup_lists) [element])])
-ec [1] [2])
-(pvec [1] [2])
-(interleave [1] [2])
-(map first [[1 2] [3 4]])
-(map (fn [x y] x) [[1 2] [3 4]])
-(map (fn [[x y]] x) [[1 2] [3 4]])
-(map (fn [[x y]] x) (interleave [1 2] [3 4]))
-(map (fn [[x y]] x) (interleave [1 2] [3 4])))
-(map (fn [[x y]] x) (interleave [1 2] [3 4]))
-(interleave [1 2] [3 4])
-(require '[clojure.zip :as zip])
-(zip [1 2] [3 4])
-(use 'clojure.zip)
-(require '[clojure.zip :as zip])
-(zip [1 2] [3 4])
-(seq-zip [1 2] [3 4])
-(+ + 1 1)
-(parition-by identity [1 1 2 1])
- (partition-by identity [1 1 2 1])
-(* [1 2] 2)
-(interleave [1 2] [1 2])
-(#(map (interleave %1) (range %2)) [1 2] 3)
-(#(map (interleave %1 %1) (range %2)) [1 2] 3)
-(interleave [1 2] [1 2] [1 2])
-(interleave [1 1 2 2] [1 2] [1 2])
-((fn go [s count]\n		(loop [s* s count* count]\n			(if (= count* 0)\n				s*\n				(recur (interleave s* s*) (- count* 1))))) [1 2 3] 2)
-((fn go [s count]\n		(loop [s* s count* (- count 1)]\n			(if (= count* 0)\n				s*\n				(recur (interleave s* s*) (- count* 1))))) [:a :b] 4)
-((flatten (map (take repeatedly %2) %1)) [1 2] 2)
-#((flatten (map (take repeatedly %2) %1)) [1 2] 2)
-(#\n	(flatten (map (take repeatedly %2) %1)) [1 2] 2)
-#(flatten (map (take repeatedly %2) %1)) [1 2] 2)
-(#(flatten (map (take repeatedly %2) %1)) [1 2] 2))
-(#(flatten (map (take repeatedly %2) %1)) [1 2] 2)
-(#(flatten (map take repeatedly %2 %1)) [1 2] 2)
-(#(flatten (map (comp take repeatedly) %2 %1)) [1 2] 2)
-(#(flatten (map (comp (take %2) repeatedly) %1)) [1 2] 2)
-((fn go [s count]\n	(flatten (map (fn [x] (take (repeatedly x) count)))) s) [1 2] 2)
-((fn go [s count]\n	(flatten (map (fn [x] (take (repeatedly x) count))) s)) [1 2] 2)
-((fn go [s count]\n	(flatten\n		(map (fn [x]\n			(take\n				(repeatedly x)\n				count))\n		s))) [1 2] 2)
-((fn go [s count]\n	(flatten\n		(map (fn [x]\n			(take\n				count\n				(repeatedly x)))\n		s))) [1 2] 3)
-(def count 3)
-(def x "a")
-(take\n					count\n					(repeatedly x))
-(repeatedly 2)
-(repeatedly identity 2)
-(repeatedly 2 identity)
-(fn go [s count]\n	(flatten\n		(map\n			(fn [x]\n				(take\n					count\n					(repeatedly x #(identity %)))\n		s)))
-)
-((fn go [s count]\n	(flatten\n		(map\n			(fn [x]\n				(take\n					count\n					(repeatedly x #(identity %))))\n		s))) [1 2] 3)
-(take\n					count\n					(repeatedly x #(identity %)))
-(take 1 (repeatedly x #(identity %)))
-ake 1 (repeatedly #(identity x)))
-((fn go [s count]\n	(flatten\n		(map\n			(fn [x]\n				(take\n					count\n					(repeatedly #(identity x))))\n		s))) [1 2] 3)
-((fn go [s count]\n	(flatten\n		(map\n			(fn [x]\n				(take\n					count\n					(repeatedly #(identity x))))\n		s))) [[1 2] [3 4]] 2)
-ef x [1 2])
-(def x [1 2])
-(def size 3)
-(take\n					size\n					(repeatedly #(identity x)))
-((fn go [s size]\n	(mapcat\n			(fn [x]\n				(take\n					size\n					(repeatedly #(identity x))))\n		s)) [[1 2] [3 4]] 2)
